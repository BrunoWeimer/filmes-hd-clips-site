<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebPlayer Premium</title>
    <style>
        :root {
            --primary: #3498db;
            --secondary: #2ecc71;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --danger: #e74c3c;
            --warning: #f39c12;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        .login-container {
            max-width: 500px;
            margin: 50px auto;
            padding: 30px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        .player-container {
            display: none;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        #videoPlayer {
            width: 100%;
            height: 500px;
            background: black;
            border-radius: 5px;
        }
        .channel-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .channel-card {
            background: white;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .channel-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .channel-card.active {
            border: 2px solid var(--primary);
            background-color: #f0f8ff;
        }
        .channel-logo {
            width: 100%;
            height: 100px;
            object-fit: contain;
        }
        input, button, select {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        button {
            background: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }
        button:hover {
            background: #2980b9;
        }
        button.secondary {
            background: var(--secondary);
        }
        button.danger {
            background: var(--danger);
        }
        button.warning {
            background: var(--warning);
        }
        .header {
            background: var(--dark);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .category-filter {
            margin: 20px 0;
            display: flex;
            gap: 10px;
        }
        .search-box {
            margin: 20px 0;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .connection-status {
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .online {
            background: var(--secondary);
        }
        .offline {
            background: var(--danger);
        }
        .server-info {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .diagnostic-panel {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .message-box {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="login-container" id="loginSection">
        <h2 style="text-align: center; margin-bottom: 30px;">Acesse Seu IPTV Premium</h2>
        <input type="text" id="username" placeholder="Usuário" autocomplete="username">
        <input type="password" id="password" placeholder="Senha" autocomplete="current-password">
        
        <div style="margin: 15px 0;">
            <label for="server">Servidor:</label>
            <input type="text" id="server" placeholder="meuservidor.xyz" value="meuservidor.xyz">
        </div>
        
        <div style="margin: 15px 0;">
            <label for="port">Porta:</label>
            <input type="text" id="port" placeholder="80" value="80">
        </div>
        
        <button id="btn-login">
            <span id="loginText">Entrar</span>
            <span id="loginSpinner" class="loading" style="display: none;"></span>
        </button>
        
        <div id="loginMessage" class="message-box"></div>
        
        <div style="margin-top: 20px; text-align: center;">
            <button onclick="runConnectionTest()" class="secondary" style="width: auto;">
                Testar Conexão
            </button>
        </div>
    </div>

    <div class="player-container" id="playerSection">
        <div class="header">
            <h2 style="margin: 0;">WebPlayer Premium</h2>
            <div style="display: flex; align-items: center; gap: 15px;">
                <span id="userInfo"></span>
                <span id="connectionStatus" class="connection-status offline">Offline</span>
                <button onclick="logout()" class="danger" style="width: auto; margin: 0;">Sair</button>
            </div>
        </div>
        
        <div class="server-info" id="serverInfo" style="display: none;">
            <h3 style="margin-top: 0;">Informações do Servidor</h3>
            <div id="serverDetails"></div>
        </div>
        
        <div class="diagnostic-panel">
            <h3 style="margin-top: 0;">Diagnóstico de Conexão</h3>
            <button onclick="runFullDiagnostic()" class="warning" style="width: auto;">Executar Diagnóstico Completo</button>
            <div id="diagnosticResults" style="margin-top: 10px;"></div>
        </div>
        
        <div id="playerMessage" class="message-box"></div>
        
        <div class="video-container">
            <video id="videoPlayer" controls></video>
        </div>
        
        <div class="search-box">
            <input type="text" id="channelSearch" placeholder="Pesquisar canal..." oninput="searchChannels()">
        </div>
        
        <div class="category-filter">
            <select id="categoryFilter" onchange="filterChannels()">
                <option value="all">Todos os Canais</option>
            </select>
            <button onclick="reloadChannels()" class="secondary" style="width: auto;">Atualizar Lista</button>
        </div>
        
        <div class="channel-list" id="channelList">
            <div style="grid-column: 1 / -1; text-align: center; padding: 20px;">
                <p>Nenhum canal carregado. Faça login primeiro.</p>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        // Função fetch com timeout
        async function fetchWithTimeout(resource, options = {}) {
            const { timeout = 8000 } = options;
            
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(resource, {
                    ...options,
                    signal: controller.signal  
                });
                
                clearTimeout(id);
                return response;
            } catch (error) {
                clearTimeout(id);
                throw error;
            }
        }

        const IPTV_PLAYER = {
            config: {
                server: "",
                port: "",
                protocol: window.location.protocol === "https:" ? "https://" : "http://",
                currentToken: "",
                hlsInstance: null,
                channels: []
            },
            
            init() {
                this.bindEvents();
                this.checkSavedCredentials();
                this.updateConnectionStatus();
            },
            
            bindEvents() {
                document.getElementById('btn-login').addEventListener('click', () => this.authenticate());
                document.getElementById('videoPlayer').addEventListener('error', (e) => {
                    console.error('Erro no player de vídeo:', e);
                    this.showPlayerMessage('Erro ao reproduzir o canal. Tente outro.', 'var(--danger)');
                });
            },
            
            checkSavedCredentials() {
                const savedServer = localStorage.getItem('iptv_server');
                const savedPort = localStorage.getItem('iptv_port');
                const savedUser = localStorage.getItem('iptv_username');
                
                if (savedServer) document.getElementById('server').value = savedServer;
                if (savedPort) document.getElementById('port').value = savedPort;
                if (savedUser) document.getElementById('username').value = savedUser;
                
                if (savedUser) document.getElementById('password').focus();
            },
            
            async authenticate() {
                const username = document.getElementById('username').value.trim();
                const password = document.getElementById('password').value.trim();
                this.config.server = document.getElementById('server').value.trim();
                this.config.port = document.getElementById('port').value.trim();
                
                if (!username || !password || !this.config.server) {
                    this.showMessage('Por favor, preencha todos os campos', 'var(--danger)');
                    return;
                }
                
                this.showLoading(true);
                this.showMessage('Conectando ao servidor...', 'var(--primary)');
                
                try {
                    // Salva as configurações
                    localStorage.setItem('iptv_server', this.config.server);
                    localStorage.setItem('iptv_port', this.config.port);
                    localStorage.setItem('iptv_username', username);
                    
                    // Testa a conexão primeiro
                    const isOnline = await this.testServerConnection();
                    if (!isOnline) {
                        throw new Error('Servidor não respondendo');
                    }
                    
                    // Tenta autenticar
                    const authData = await this.tryAuthMethods(username, password);
                    
                    if (!authData) {
                        throw new Error('Nenhum método de autenticação funcionou');
                    }
                    
                    // Autenticação bem-sucedida
                    localStorage.setItem('iptv_username', username);
                    this.config.currentToken = btoa(`${username}:${password}`);
                    
                    this.loadPlayer(authData.user_info || {username: username, status: 'Active'}, username, password);
                    this.showMessage('Login bem-sucedido!', 'var(--secondary)');
                    this.updateConnectionStatus(true);
                    
                } catch (error) {
                    console.error('Erro na autenticação:', error);
                    this.showMessage(`Falha no login: ${error.message}`, 'var(--danger)');
                    this.updateConnectionStatus(false);
                    
                    // Tenta o método alternativo com proxy
                    if (error.message.includes('Nenhum método')) {
                        this.showMessage('Tentando método alternativo...', 'var(--warning)');
                        await this.tryProxyMethod(username, password);
                    }
                } finally {
                    this.showLoading(false);
                }
            },
            
            async tryAuthMethods(username, password) {
                const methods = [
                    // Método 1: Xtream Codes padrão
                    {
                        url: `${this.config.protocol}${this.config.server}:${this.config.port}/player_api.php?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`,
                        type: 'json'
                    },
                    // Método 2: Formato alternativo
                    {
                        url: `${this.config.protocol}${this.config.server}:${this.config.port}/api.php?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`,
                        type: 'json'
                    },
                    // Método 3: Autenticação básica
                    {
                        url: `${this.config.protocol}${this.config.server}:${this.config.port}/player_api.php`,
                        type: 'json',
                        headers: {
                            'Authorization': `Basic ${btoa(username + ":" + password)}`
                        }
                    },
                    // Método 4: Lista M3U direta
                    {
                        url: `${this.config.protocol}${this.config.server}:${this.config.port}/get.php?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}&type=m3u_plus`,
                        type: 'm3u'
                    }
                ];
                
                for (const method of methods) {
                    try {
                        console.log(`Tentando método: ${method.url}`);
                        const response = await fetchWithTimeout(method.url, {
                            headers: method.headers || {},
                            timeout: 5000
                        });
                        
                        if (!response.ok) {
                            console.log(`Método falhou com status: ${response.status}`);
                            continue;
                        }
                        
                        if (method.type === 'json') {
                            const data = await response.json();
                            if (data.user_info || data.status === 'Active') {
                                console.log('Autenticação bem-sucedida via JSON');
                                return data;
                            }
                        } else if (method.type === 'm3u') {
                            const data = await response.text();
                            if (data.includes('#EXTM3U')) {
                                console.log('Autenticação bem-sucedida via M3U');
                                return { user_info: {username, status: 'Active'}, playlist: data };
                            }
                        }
                    } catch (e) {
                        console.log(`Método falhou com erro: ${e.message}`);
                        continue;
                    }
                }
                return null;
            },
            
            async tryProxyMethod(username, password) {
                try {
                    const proxyUrl = `proxy.php?server=${encodeURIComponent(this.config.server)}&port=${encodeURIComponent(this.config.port)}&username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`;
                    
                    const response = await fetchWithTimeout(proxyUrl, { timeout: 10000 });
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    if (data.user_info) {
                        this.loadPlayer(data.user_info, username, password);
                        this.showMessage('Conexão estabelecida via proxy!', 'var(--secondary)');
                        return true;
                    }
                    
                    if (data.playlist) {
                        this.loadPlayer({username, status: 'Active'}, username, password);
                        this.parseM3U(data.playlist);
                        this.showMessage('Lista carregada via proxy!', 'var(--secondary)');
                        return true;
                    }
                    
                    throw new Error('Resposta inválida do proxy');
                    
                } catch (error) {
                    console.error('Falha no proxy:', error);
                    this.showMessage(`Proxy também falhou: ${error.message}`, 'var(--danger)');
                    return false;
                }
            },
            
            async testServerConnection() {
                this.updateConnectionStatus(false);
                this.showMessage('Testando conexão com o servidor...', 'var(--primary)');
                
                try {
                    const portsToTest = [
                        this.config.port,
                        80,
                        8080,
                        8000,
                        25463,
                        2095
                    ].filter(p => p); // Remove portas vazias

                    const uniquePorts = [...new Set(portsToTest)]; // Remove duplicatas
                    
                    let workingPort = null;
                    
                    for (const port of uniquePorts) {
                        try {
                            const testUrl = `${this.config.protocol}${this.config.server}:${port}`;
                            console.log(`Testando conexão em: ${testUrl}`);
                            
                            const response = await fetchWithTimeout(testUrl, { 
                                method: 'HEAD',
                                timeout: 5000
                            });
                            
                            if (response.ok) {
                                workingPort = port;
                                break;
                            }
                        } catch (e) {
                            console.log(`Porta ${port} falhou: ${e.message}`);
                            continue;
                        }
                    }

                    if (!workingPort) {
                        throw new Error('Nenhuma porta respondeu');
                    }

                    this.config.port = workingPort;
                    document.getElementById('port').value = workingPort;
                    localStorage.setItem('iptv_port', workingPort);
                    
                    this.showMessage(`Conexão estabelecida na porta ${workingPort}`, 'var(--secondary)');
                    this.updateConnectionStatus(true);
                    return true;
                    
                } catch (error) {
                    console.error('Falha na conexão:', error);
                    this.showMessage(`Servidor não respondendo: ${error.message}`, 'var(--danger)');
                    this.updateConnectionStatus(false);
                    return false;
                }
            },
            
            async loadPlayer(userInfo, username, password) {
                document.getElementById('loginSection').style.display = 'none';
                document.getElementById('playerSection').style.display = 'block';
                
                document.getElementById('userInfo').textContent = `Bem-vindo, ${userInfo.username}`;
                
                await this.loadServerInfo(username, password);
                await this.loadChannelList(username, password);
                await this.loadCategories(username, password);
            },
            
            async loadServerInfo(username, password) {
                try {
                    const infoUrl = `${this.config.protocol}${this.config.server}:${this.config.port}/player_api.php?username=${username}&password=${password}&action=get_server_info`;
                    const response = await fetchWithTimeout(infoUrl, { timeout: 5000 });
                    
                    if (response.ok) {
                        const data = await response.json();
                        let html = `
                            <p><strong>Nome:</strong> ${data.server_name || 'N/A'}</p>
                            <p><strong>Status:</strong> ${data.status || 'N/A'}</p>
                            <p><strong>Clientes:</strong> ${data.active_connections || '0'} / ${data.max_connections || 'N/A'}</p>
                        `;
                        document.getElementById('serverDetails').innerHTML = html;
                        document.getElementById('serverInfo').style.display = 'block';
                    }
                } catch (error) {
                    console.error('Erro ao carregar info do servidor:', error);
                }
            },
            
            async loadChannelList(username, password, retry = true) {
                try {
                    this.showPlayerMessage('Carregando lista de canais...', 'var(--primary)');
                    
                    // Tenta obter a lista via API
                    let m3uContent = '';
                    const apiUrl = `${this.config.protocol}${this.config.server}:${this.config.port}/player_api.php?username=${username}&password=${password}&action=get_live_streams`;
                    const apiResponse = await fetchWithTimeout(apiUrl, { timeout: 7000 });
                    
                    if (apiResponse.ok) {
                        const data = await apiResponse.json();
                        if (Array.isArray(data)) {
                            m3uContent = '#EXTM3U\n';
                            data.forEach(channel => {
                                m3uContent += `#EXTINF:-1 tvg-id="${channel.id}" tvg-name="${channel.name}" tvg-logo="${channel.logo}" group-title="${channel.category_name}",${channel.name}\n`;
                                m3uContent += `${channel.stream_url}\n`;
                            });
                        }
                    }
                    
                    // Se não obteve pela API, tenta o M3U diretamente
                    if (!m3uContent) {
                        const m3uUrl = `${this.config.protocol}${this.config.server}:${this.config.port}/get.php?username=${username}&password=${password}&type=m3u_plus`;
                        const m3uResponse = await fetchWithTimeout(m3uUrl, { timeout: 10000 });
                        m3uContent = await m3uResponse.text();
                    }
                    
                    if (!m3uContent.includes('#EXTM3U')) {
                        throw new Error('Formato de lista inválido');
                    }
                    
                    this.parseM3U(m3uContent);
                    this.showPlayerMessage('Lista de canais carregada com sucesso!', 'var(--secondary)');
                    
                } catch (error) {
                    console.error('Erro ao carregar canais:', error);
                    this.showPlayerMessage('Erro ao carregar lista de canais', 'var(--danger)');
                    
                    if (retry) {
                        // Tenta novamente com autenticação básica
                        try {
                            const m3uUrl = `${this.config.protocol}${this.config.server}:${this.config.port}/get.php?username=${username}&password=${password}&type=m3u_plus`;
                            const response = await fetchWithTimeout(m3uUrl, {
                                headers: {
                                    'Authorization': `Basic ${this.config.currentToken}`
                                },
                                timeout: 10000
                            });
                            const m3uContent = await response.text();
                            this.parseM3U(m3uContent);
                        } catch (e) {
                            console.error('Falha na segunda tentativa:', e);
                        }
                    }
                }
            },
            
            parseM3U(m3uContent) {
                const lines = m3uContent.split('\n');
                this.config.channels = [];
                const channelList = document.getElementById('channelList');
                channelList.innerHTML = '';
                
                let currentChannel = {};
                
                lines.forEach(line => {
                    if (line.startsWith('#EXTINF:')) {
                        currentChannel = {
                            name: line.split(',')[1],
                            group: '',
                            logo: ''
                        };
                        
                        const attrs = line.match(/tvg-([^=]+)="([^"]+)"/g);
                        if (attrs) {
                            attrs.forEach(attr => {
                                const [key, value] = attr.replace(/"/g, '').split('=');
                                currentChannel[key] = value;
                                if (key === 'tvg-logo') currentChannel.logo = value;
                                if (key === 'tvg-group') currentChannel.group = value;
                            });
                        }
                    } else if (line.startsWith('http')) {
                        currentChannel.url = line.trim();
                        this.config.channels.push(currentChannel);
                        this.createChannelCard(currentChannel);
                        currentChannel = {};
                    }
                });
                
                this.updateCategoryFilter();
            },
            
            createChannelCard(channel) {
                const channelList = document.getElementById('channelList');
                const card = document.createElement('div');
                card.className = 'channel-card';
                card.onclick = () => this.playChannel(channel);
                
                const logo = channel.logo ? 
                    `<img src="${channel.logo}" alt="${channel.name}" class="channel-logo" onerror="this.src='https://via.placeholder.com/200x100?text=LOGO'">` : 
                    `<div class="channel-logo" style="display:flex;align-items:center;justify-content:center;background:#eee;color:#333;">${channel.name}</div>`;
                
                card.innerHTML = `
                    ${logo}
                    <h3 style="margin:10px 0;text-align:center;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${channel.name}</h3>
                `;
                
                if (channel.group) {
                    card.dataset.category = channel.group.toLowerCase();
                    card.dataset.name = channel.name.toLowerCase();
                }
                
                channelList.appendChild(card);
            },
            
            playChannel(channel) {
                const videoPlayer = document.getElementById('videoPlayer');
                
                document.querySelectorAll('.channel-card').forEach(c => {
                    c.classList.remove('active');
                });
                
                event.currentTarget.classList.add('active');
                
                if (this.config.hlsInstance) {
                    this.config.hlsInstance.destroy();
                }
                videoPlayer.pause();
                
                this.showPlayerMessage(`Carregando: ${channel.name}`, 'var(--primary)');
                
                if (channel.url.includes('.m3u8')) {
                    if (Hls.isSupported()) {
                        this.config.hlsInstance = new Hls();
                        this.config.hlsInstance.loadSource(channel.url);
                        this.config.hlsInstance.attachMedia(videoPlayer);
                        this.config.hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
                            videoPlayer.play();
                            this.showPlayerMessage(`Agora tocando: ${channel.name}`, 'var(--secondary)');
                        });
                        this.config.hlsInstance.on(Hls.Events.ERROR, (event, data) => {
                            console.error('HLS Error:', data);
                            if (data.fatal) {
                                switch(data.type) {
                                    case Hls.ErrorTypes.NETWORK_ERROR:
                                        this.showPlayerMessage('Erro de rede. Tentando reconectar...', 'var(--danger)');
                                        this.config.hlsInstance.startLoad();
                                        break;
                                    case Hls.ErrorTypes.MEDIA_ERROR:
                                        this.showPlayerMessage('Erro de mídia. Recuperando...', 'var(--danger)');
                                        this.config.hlsInstance.recoverMediaError();
                                        break;
                                    default:
                                        this.showPlayerMessage('Erro ao reproduzir este canal', 'var(--danger)');
                                        break;
                                }
                            }
                        });
                    } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                        videoPlayer.src = channel.url;
                        videoPlayer.play().catch(e => {
                            this.showPlayerMessage('Erro ao reproduzir: clique para tentar novamente', 'var(--danger)');
                        });
                    } else {
                        this.showPlayerMessage('Seu navegador não suporta este formato de vídeo', 'var(--danger)');
                    }
                } else {
                    videoPlayer.src = channel.url;
                    videoPlayer.play().catch(e => {
                        this.showPlayerMessage('Erro ao reproduzir: clique para tentar novamente', 'var(--danger)');
                    });
                }
            },
            
            async loadCategories(username, password) {
                try {
                    const apiUrl = `${this.config.protocol}${this.config.server}:${this.config.port}/player_api.php?username=${username}&password=${password}&action=get_live_categories`;
                    const response = await fetchWithTimeout(apiUrl, { timeout: 5000 });
                    
                    if (response.ok) {
                        const categories = await response.json();
                        this.updateCategoryFilter(categories);
                    }
                } catch (error) {
                    console.error('Erro ao carregar categorias:', error);
                    this.updateCategoryFilter();
                }
            },
            
            updateCategoryFilter(categories = null) {
                const filter = document.getElementById('categoryFilter');
                const currentValue = filter.value;
                
                filter.innerHTML = '<option value="all">Todos os Canais</option>';
                
                if (categories) {
                    categories.forEach(cat => {
                        const option = document.createElement('option');
                        option.value = cat.category_name.toLowerCase();
                        option.textContent = cat.category_name;
                        filter.appendChild(option);
                    });
                } else {
                    const categorySet = new Set();
                    this.config.channels.forEach(ch => {
                        if (ch.group) categorySet.add(ch.group);
                    });
                    
                    categorySet.forEach(cat => {
                        const option = document.createElement('option');
                        option.value = cat.toLowerCase();
                        option.textContent = cat;
                        filter.appendChild(option);
                    });
                }
                
                if (currentValue && Array.from(filter.options).some(o => o.value === currentValue)) {
                    filter.value = currentValue;
                }
            },
            
            filterChannels() {
                const category = document.getElementById('categoryFilter').value.toLowerCase();
                const searchTerm = document.getElementById('channelSearch').value.toLowerCase();
                
                document.querySelectorAll('.channel-card').forEach(card => {
                    const matchesCategory = category === 'all' || card.dataset.category === category;
                    const matchesSearch = !searchTerm || card.dataset.name.includes(searchTerm);
                    
                    card.style.display = matchesCategory && matchesSearch ? 'block' : 'none';
                });
            },
            
            searchChannels() {
                this.filterChannels();
            },
            
            reloadChannels() {
                const username = localStorage.getItem('iptv_username');
                const password = prompt("Digite sua senha novamente:");
                
                if (password) {
                    this.loadChannelList(username, password);
                }
            },
            
            async runFullDiagnostic() {
                const resultsEl = document.getElementById('diagnosticResults');
                resultsEl.innerHTML = '<p>Executando testes...</p>';
                
                const tests = [
                    { name: 'Conexão básica com o servidor', test: this.testServerConnection },
                    { name: 'Acesso à API principal', test: this.testAPIAccess },
                    { name: 'Download da lista M3U', test: this.testM3UDownload }
                ];
                
                let allTestsPassed = true;
                let resultsHTML = '';
                
                for (const test of tests) {
                    try {
                        resultsHTML += `<p><strong>${test.name}:</strong> `;
                        const result = await test.test.call(this);
                        
                        if (result) {
                            resultsHTML += '<span style="color:green">✓ Sucesso</span>';
                        } else {
                            resultsHTML += '<span style="color:red">✕ Falhou</span>';
                            allTestsPassed = false;
                        }
                        
                        resultsHTML += '</p>';
                    } catch (e) {
                        resultsHTML += `<p><strong>${test.name}:</strong> <span style="color:red">✕ Erro: ${e.message}</span></p>`;
                        allTestsPassed = false;
                    }
                    
                    resultsEl.innerHTML = resultsHTML;
                }
                
                if (allTestsPassed) {
                    resultsHTML += '<p style="color:green;font-weight:bold;">✓ Todos os testes passaram!</p>';
                } else {
                    resultsHTML += '<p style="color:red;font-weight:bold;">✕ Alguns testes falharam. Verifique as configurações.</p>';
                }
                
                resultsEl.innerHTML = resultsHTML;
            },
            
            async testAPIAccess() {
                const username = document.getElementById('username').value.trim();
                const password = document.getElementById('password').value.trim();
                
                if (!username || !password) {
                    throw new Error('Credenciais não fornecidas');
                }
                
                const apiUrl = `${this.config.protocol}${this.config.server}:${this.config.port}/player_api.php?username=${username}&password=${password}`;
                const response = await fetchWithTimeout(apiUrl, { timeout: 5000 });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                return !!data.user_info;
            },
            
            async testM3UDownload() {
                const username = document.getElementById('username').value.trim();
                const password = document.getElementById('password').value.trim();
                
                if (!username || !password) {
                    throw new Error('Credenciais não fornecidas');
                }
                
                const m3uUrl = `${this.config.protocol}${this.config.server}:${this.config.port}/get.php?username=${username}&password=${password}&type=m3u_plus`;
                const response = await fetchWithTimeout(m3uUrl, { timeout: 8000 });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.text();
                return data.includes('#EXTM3U');
            },
            
            showMessage(msg, color = 'var(--danger)') {
                const msgEl = document.getElementById('loginMessage');
                msgEl.textContent = msg;
                msgEl.style.color = color;
                msgEl.style.display = msg ? 'block' : 'none';
            },
            
            showPlayerMessage(msg, color = 'var(--danger)') {
                const msgEl = document.getElementById('playerMessage');
                msgEl.textContent = msg;
                msgEl.style.color = color;
                msgEl.style.display = msg ? 'block' : 'none';
            },
            
            showLoading(show) {
                document.getElementById('loginText').style.display = show ? 'none' : 'inline';
                document.getElementById('loginSpinner').style.display = show ? 'inline-block' : 'none';
                document.getElementById('btn-login').disabled = show;
            },
            
            updateConnectionStatus(isConnected = false) {
                const statusEl = document.getElementById('connectionStatus');
                statusEl.textContent = isConnected ? 'Online' : 'Offline';
                statusEl.className = `connection-status ${isConnected ? 'online' : 'offline'}`;
            },
            
            logout() {
                localStorage.removeItem('iptv_username');
                document.getElementById('loginSection').style.display = 'block';
                document.getElementById('playerSection').style.display = 'none';
                document.getElementById('username').value = localStorage.getItem('iptv_username') || '';
                document.getElementById('password').value = '';
                
                if (this.config.hlsInstance) {
                    this.config.hlsInstance.destroy();
                }
                
                document.getElementById('videoPlayer').src = '';
                this.updateConnectionStatus(false);
                this.showMessage('');
                this.showPlayerMessage('');
            }
        };

        // Funções globais para chamadas a partir do HTML
        function runConnectionTest() {
            IPTV_PLAYER.config.server = document.getElementById('server').value.trim();
            IPTV_PLAYER.config.port = document.getElementById('port').value.trim();
            IPTV_PLAYER.testServerConnection();
        }
        
        function runFullDiagnostic() {
            IPTV_PLAYER.runFullDiagnostic();
        }
        
        function filterChannels() {
            IPTV_PLAYER.filterChannels();
        }
        
        function searchChannels() {
            IPTV_PLAYER.searchChannels();
        }
        
        function reloadChannels() {
            IPTV_PLAYER.reloadChannels();
        }
        
        function logout() {
            IPTV_PLAYER.logout();
        }
        
        // Inicializa quando o DOM estiver pronto
        document.addEventListener('DOMContentLoaded', () => IPTV_PLAYER.init());
    </script>
</body>
</html>
